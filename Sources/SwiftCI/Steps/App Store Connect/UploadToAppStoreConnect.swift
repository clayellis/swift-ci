import Foundation

public struct UploadToAppStoreConnect: Step {

    public enum Authentication {
        // TODO: Username/Password authentication
        /// apiKey. Required for JWT authentication (in lieu of username/password).
        ///
        /// This option will search the following directories in sequence for a private key file with the name of 'AuthKey_<api_key>.p8': './private_keys', '~/private_keys', '~/.private_keys', and '~/.appstoreconnect/private_keys'.
        ///
        /// Additionally, you can set the environment variable $API_PRIVATE_KEYS_DIR or a user default API_PRIVATE_KEYS_DIR to specify the directory where your AuthKey file is located.
        ///
        /// Issuer ID. Required if --apiKey is specified.
        case apiKey(String, issuerID: String, keyDirectory: String)
    }

    public enum PackageType: Argument {
        case macOS
        case iOS
        case tvOS

        public var argument: String {
            switch self {
            case .macOS: return "macos"
            case .iOS: return "ios"
            case .tvOS: return "appletvos"
            }
        }
    }

    /// File path.
    let ipa: String

    /// The package type,
    var type: PackageType = .iOS

    /// Required with --notarize-app and --notarization-history when a user account is associated with multiple providers and using username/password authentication.
    /// You can use the --list-providers command to retrieve the providers associated with your accounts. You may instead use --asc-provider or --asc-public-id.
    var ascPublicID: String? = nil

    /// The Apple ID of the app to be uploaded.
    var appleID: String?

    /// The CFBundleVersion of the app to be uploaded.
    var bundleVersion: String?

    /// The CFBundleShortVersionString of the app to be uploaded.
    var bundleShortVersion: String?

    /// The CFBundleIdentifier of the app to be uploaded.
    var bundleID: String?

    /// The type of authentication to use.
    let authentication: Authentication
    var showProgress: Bool = false
    var verbose: Bool = false

    private func newALToolCommand() -> Command {
        if case .apiKey(let apiKey, let issuerID, let keyDirectory) = authentication {
            return Command("env", "API_PRIVATE_KEYS_DIR=\(keyDirectory)", "xcrun", "altool", "--apiKey", apiKey, "--apiIssuer", issuerID)
        } else {
            return Command("xcrun", "altool")
        }
    }

    public func run() async throws {
        var appleID = self.appleID
        var bundleVersion = self.bundleVersion
        var bundleShortVersion = self.bundleShortVersion
        var bundleID = self.bundleID

        if bundleVersion == nil || bundleShortVersion == nil || bundleID == nil {
            let distributionSummary = try getDistributionSummary()
            var summary: DistributionSummary.ProductSummary?

            if ipa.hasSuffix(".ipa"), let ipaName = ipa.components(separatedBy: "/").last {
                summary = distributionSummary.summaries[ipaName]?.first
            } else if distributionSummary.summaries.values.count == 1 {
                summary = distributionSummary.summaries.values.first?.first
            }

            guard let summary else {
                throw StepError("Could not determine bundleVersion, bundleShortVersion, or bundleID from distribution summary.")
            }

            if bundleVersion == nil {
                bundleVersion = summary.buildNumber
            }

            if bundleShortVersion == nil {
                bundleShortVersion = summary.versionNumber
            }

            if bundleID == nil {
                bundleID = summary.entitlements.bundleID
            }
        }

        guard let bundleVersion else { fatalError("Missing bundleVersion") }
        guard let bundleShortVersion else { fatalError("Missing bundleShortVersion") }
        guard let bundleID else { fatalError("Missing bundleID") }

        if appleID == nil {
            let apps = try await listApps()
            if let matchingApp = apps.applications.first(where: { $0.bundleID == bundleID }) {
                appleID = matchingApp.appleID
            }
        }

        guard let appleID else { fatalError("Missing appleID") }

        var altool = newALToolCommand()
        altool.add(
            "--upload-package", ipa,
            "--type", type,
            // we can get this by listing all apps first and looking up the apple id
            "--apple-id", appleID,
            // we can get this by validating the build first and looking for version error to resolve (or use app store connect api to fetch the current version)
            // we can also get this from the distributionsummary.plist generated by the export archive step if manageAppVersionAndBuildNumber was set to true
            "--bundle-version", bundleVersion,
            // we can get this from the xcode project itself
            // or from the distributionsummary.plist
            "--bundle-short-version-string", bundleShortVersion,
            // we can get this from the xcode project
            "--bundle-id", bundleID
        )

        if let ascPublicID {
            altool.add("--asc-public-id", ascPublicID)
        }

        if showProgress {
            altool.add("--show-progress")
        }

        if verbose {
            altool.add("--verbose")
        }

        try context.shell(altool)
    }
}

public extension Step where Self == UploadToAppStoreConnect {
    static func uploadToAppStoreConnect(
        ipa: String,
        type: Self.PackageType = .iOS,
        ascPublicID: String? = nil,
        appAppleID: String? = nil,
        bundleVersion: String? = nil,
        bundleShortVersion: String? = nil,
        bundleID: String? = nil,
        authentication: Self.Authentication,
        showProgress: Bool = false,
        verbose: Bool = false
    ) -> Self {
        Self.init(
            ipa: ipa,
            type: type,
            ascPublicID: ascPublicID,
            appleID: appAppleID,
            bundleVersion: bundleVersion,
            bundleShortVersion: bundleShortVersion,
            bundleID: bundleID,
            authentication: authentication,
            showProgress: showProgress,
            verbose: verbose
        )
    }
}

extension UploadToAppStoreConnect {
    struct ListAppsReponse: Decodable {
        let applications: [App]

        struct App: Decodable {
            let appleID: String
            let bundleID: String

            enum CodingKeys: String, CodingKey {
                case appleID = "AppleID"
                case bundleID = "ReservedBundleIdentifier"
            }
        }
    }

    func listApps() async throws -> ListAppsReponse {
        var listApps = newALToolCommand()
        listApps.add("--list-apps", "--output-format", "json")
        let responseString = try context.shell(listApps)
        let responseData = Data(responseString.utf8)
        let response = try JSONDecoder().decode(ListAppsReponse.self, from: responseData)
        return response
    }
}

extension UploadToAppStoreConnect {
    struct DistributionSummary: Decodable {
        let summaries: [String: [ProductSummary]]

        struct ProductSummary: Decodable {
            let buildNumber: String
            let versionNumber: String
            let entitlements: Entitlements

            struct Entitlements: Decodable {
                let applicationIdentifier: String
                let teamIdentifier: String

                enum CodingKeys: String, CodingKey {
                    case applicationIdentifier = "application-identifier"
                    case teamIdentifier = "com.apple.developer.team-identifier"
                }

                var bundleID: String? {
                    let prefix = teamIdentifier + "."

                    guard applicationIdentifier.hasPrefix(prefix) else {
                        return nil
                    }

                    return String(applicationIdentifier.dropFirst(prefix.count))
                }
            }
        }

        init(from decoder: Decoder) throws {
            var container = try decoder.singleValueContainer()
            summaries = try container.decode([String: [ProductSummary]].self)
        }
    }

    func getDistributionSummary() throws -> DistributionSummary {
        var distributionSummaryPath: String

        if ipa.hasSuffix(".ipa") {
            distributionSummaryPath = ipa
                .components(separatedBy: "/")
                .dropLast()
                .joined(separator: "/")
                + "/"
        } else {
            distributionSummaryPath = ipa
        }

        distributionSummaryPath += "DistributionSummary.plist"

        guard let contents = context.fileManager.contents(atPath: distributionSummaryPath) else {
            fatalError()
        }

        do {
            let distributionSummary = try PropertyListDecoder().decode(DistributionSummary.self, from: contents)
            return distributionSummary
        } catch {
            print(error)
            fatalError()
        }
    }
}
